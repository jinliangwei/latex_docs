\documentclass{beamer}
\usepackage{beamerthemesplit} % new 

\usetheme{default}
\useoutertheme{infolines}
%\setbeamertemplate{navigation symbols}{gd} 

\begin{document}


\title{Concurrent LRU Based on Concurrent Hash Table} 
\author{Jinliang Wei} 
\date{\today} 

\frame{\titlepage} 

\frame{\frametitle{Table of contents}\tableofcontents} 

\section{Process Storage}

\begin{frame}
\frametitle{Process Storage Basics}
ProcessStorage caches a set of rows. The maximum number of row can be stored is
\emph{capacity}. Caching means that 
\begin{enumerate}
\item The storage does not necessarily contains the row that its clients ask for;
\item Resident rows may get evicted anytime unless it's properly protected by 
reference counting. 
\end{enumerate}

\end{frame}

\begin{frame}
\frametitle{Process Storage API - \texttt{Find()}}
Set the accessor to point to the row specified by 
  the row index. Once an accessor is set, it is guaranteed to remain valid until
 the accessor is destroyed. ``Remain valid'' means that reading
from the accessor always returns some value. However, whether or not the value 
satisfies the consistency requirements depends on the specific consistency model.
\begin{itemize}
\item SSP: Freshness of the value read from accessor is not guaranteed across iterations.
  Generally, accessors from a previous iteration should not be reused.
\item VAP: accessors remains valid throughout the execution.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Process Storage API - \texttt{Insert()}}
Insert a client row (including metadata). Optionally it returns the evicted row and
provides an accessor to the inserted row. \texttt{Insert()} assumes the number of rows
being referenced never reaches \emph{capacity} of the ProcessStorage.
The insertion logic is as follows:
\begin{enumerate}
\item If the row index does not exist in the ProcessStorage, the row is inserted
 into an empty slot. If ProcessStorage cannot find an empty slot, it may evict an
 resident row that have zero reference count.
\item If the row index already exist
\end{enumerate}

\end{frame}

\begin{frame}
\frametitle{Process Storage Thread Safety}
\end{frame}

\begin{frame}
\frametitle{Process Storage Assumptions and Guarantees}
\begin{itemize}
\item Process Storage is initialized with a \emph{capacity} number. It 
guarantees that the number of rows cached in ProcessStorage does not exceed 
\emph{capacity} (with a minor exception as explained later).

\item Rows are accessed via accessors which essentially hold a reference to
a row. If too many (equal to \emph{capacity}) rows are being accessed 
(references are held to them), the process storage won't be able to evict
any row so it cannot insert a new row.

\end{itemize}
\end{frame}

\section{Per-Row Reference Count}

\begin{frame}
Per-Row Reference Count
\end{frame}

\begin{frame}
\frametitle{Major Data Structures}
\begin{itemize}
\item Concurrent Cuckoo hash: support concurrent insert, look-up and delete; 
support dynamic resizing; does not support concurrent traversal. The hash table
maps row index to client row pointer.
\item Striped lock: each lock guards a disjoint subset of row indices. A lock 
guarantees exclusive accesses to the object stored in the hash table for operations
that may alter the validity of the object and operations that requires the validity 
to remain unchanged throughout the course of excution.
\item An integer to denote the number of occupied slots in the hash table.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Major Data Structures - CLOCK LRU}
CLOCK LRU logic, which contains the following data structures (bitsets and
 array are sized to capacity):
\begin{itemize}
\item A bitset of eviction bits: each bit denotes if a row can be evicted. If 
the bit is set, the slot is evictable otherwise it is not. This particular 
representation is to accomodate the operations of \texttt{std::atomic\_flag}.
\item A bitset of occupation bits: each bit denotes if the slot is occupied by a
resident row. If the bit is set, it denotes that the mapping from slot number
to row index points to a resident row in the hash table.
\item An array of integers mapping slot number to row index. This is needed when
finding a row to evict.
\item An thread-safe queue to store 
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Semantics of the Striped Lock}
\begin{itemize}
\item The striped lock is shared between ProcessStorage and its component CLOCK 
LRU.
\item Since a lock guards the validity of client row pointers stored in the hash
  table, the lock should be acquired when
\begin{enumerate}
\item The operation might invalidate the row pointer (e.g. erasing the row from 
  the hash table);
\item Or the operation requires the validity of the row but cannot guarantee that
via other means (e.g. reference counting).
\end{enumerate}
\item Since the occupation bits denotes the occupation of the slots by the resident
row, operations on the 
\item As shown later, this should be the only cases where lock is necessary.
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{CLOCK LRU High Level Idea}
\begin{itemize}
\item The ProcessStorage employs CLOCK LRU as a manager for eviction. The eviction makes 
assumption about ProcessStorage and provides certain guarantees.
\item The LRU logic keeps track of number $C$ rows, where $C$ is the cache capacity. We
refer to such space as LRU slots for rows. 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{CLOCK LRU Interface}
The CLOCK LRU logic shares access to the striped lock and the hash table, and 
provides the following APIs:

\begin{itemize}
\item \texttt{Evict()}: pick a row and erase it from the hash table. 
  It guarantees to not evict a row that has non-zero reference count. It might
  be stuck in an infinite loop or return failure if all resident rows have non-zero
  reference count. The eviction respects the sematics of the striped lock. Once
  succeed, the number of occupied LRU slots is decremented by 1.
\item \texttt{Insert()}: notify the LRU logic that a row is resident in the 
  hash table. A row cannot become a cadidate for eviction until \texttt{Insert()}
  is invoked. Once succeed, the number of occupied LRU slots is incremented by 1.
  It does not access striped lock.
\item \texttt{Reference()}: notify the LRU logic that a slot is recently accessed.
A parameter to this function is the slot number. LRU takes this a hint. It does 
not access striped lock.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{CLOCK LRU Assumptions}
\begin{itemize}
\item \texttt{Insert()} is invoked only if the number of occupied slots plus the 
  number of concurrent Insert() is strictly below cache capacity.
\item \texttt{Evict()} is invoked only if the numer of occupied slots minus the 
  number of concurrent Evict() is strictly larger than 0.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Regarding Occupation Bits}
\begin{itemize}
\item The occupation bits are concerned about two operations: insert and evict.
\item Eviction cannot happen to an empty slot and insertion cannot happen to an 
occupied slot.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{CLOCK LRU Implementation - \texttt{Evict()}}

\begin{enumerate}
\item Atomically fetch the value of the 
\end{enumerate}
Details on LRU and ProcessStorage implementation will follow.
\end{frame}

\section{Grouped Reference Count}

\begin{frame}
Grouped Reference Count
\end{frame}


\begin{frame}
\frametitle{Main Idea}

Store reference count outside of row object (possibly in LRU cache) to allow 
double-checked locking when access a resident row.

\end{frame}


\end{document}

